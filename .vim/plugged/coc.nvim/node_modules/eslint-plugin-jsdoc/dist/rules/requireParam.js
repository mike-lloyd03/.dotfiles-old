"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _iterateJsdoc = _interopRequireDefault(require("../iterateJsdoc"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const rootNamer = (desiredRoots, currentIndex) => {
  let name;
  let idx = currentIndex;
  const incremented = desiredRoots.length <= 1;

  if (incremented) {
    const base = desiredRoots[0];
    const suffix = idx++;
    name = `${base}${suffix}`;
  } else {
    name = desiredRoots.shift();
  }

  return [name, incremented, () => {
    return rootNamer(desiredRoots, idx);
  }];
};

var _default = (0, _iterateJsdoc.default)(({
  jsdoc,
  node,
  utils,
  context
}) => {
  const functionParameterNames = utils.getFunctionParameterNames();
  const preferredTagName = utils.getPreferredTagName({
    tagName: 'param'
  });

  if (!preferredTagName) {
    return;
  }

  const jsdocParameterNames = utils.getJsdocTagsDeep(preferredTagName);
  const shallowJsdocParameterNames = jsdocParameterNames.filter(tag => {
    return !tag.name.includes('.');
  }).map((tag, idx) => {
    return _objectSpread(_objectSpread({}, tag), {}, {
      idx
    });
  });

  if (utils.avoidDocs()) {
    return;
  } // Param type is specified by type in @type


  if (utils.hasTag('type')) {
    return;
  }

  const _ref = context.options[0] || {},
        _ref$enableFixer = _ref.enableFixer,
        enableFixer = _ref$enableFixer === void 0 ? true : _ref$enableFixer,
        _ref$enableRootFixer = _ref.enableRootFixer,
        enableRootFixer = _ref$enableRootFixer === void 0 ? true : _ref$enableRootFixer,
        _ref$checkRestPropert = _ref.checkRestProperty,
        checkRestProperty = _ref$checkRestPropert === void 0 ? false : _ref$checkRestPropert,
        _ref$enableRestElemen = _ref.enableRestElementFixer,
        enableRestElementFixer = _ref$enableRestElemen === void 0 ? true : _ref$enableRestElemen,
        _ref$checkTypesPatter = _ref.checkTypesPattern,
        checkTypesPattern = _ref$checkTypesPatter === void 0 ? '/^(?:[oO]bject|[aA]rray|PlainObject|Generic(?:Object|Array))$/' : _ref$checkTypesPatter;

  const lastSlashPos = checkTypesPattern.lastIndexOf('/');
  const checkTypesRegex = lastSlashPos === -1 ? new RegExp(checkTypesPattern) : new RegExp(checkTypesPattern.slice(1, lastSlashPos), checkTypesPattern.slice(lastSlashPos + 1));
  const missingTags = [];
  const flattenedRoots = utils.flattenRoots(functionParameterNames).names;
  const paramIndex = flattenedRoots.reduce((acc, cur, idx) => {
    acc[cur] = idx;
    return acc;
  }, {});

  const findExpectedIndex = (jsdocTags, indexAtFunctionParams) => {
    const remainingRoots = functionParameterNames.slice(indexAtFunctionParams || 0);
    const foundIndex = jsdocTags.findIndex(({
      name,
      newAdd
    }) => {
      return !newAdd && remainingRoots.some(remainingRoot => {
        if (Array.isArray(remainingRoot)) {
          return remainingRoot[1].names.includes(name);
        }

        if (typeof remainingRoot === 'object') {
          return name === remainingRoot.name;
        }

        return name === remainingRoot;
      });
    });

    if (foundIndex > -1) {
      return foundIndex;
    }

    const paramTags = jsdocTags.filter(({
      tag
    }) => {
      return tag === preferredTagName;
    });
    return paramTags.length;
  };

  const _ref2 = context.options[0] || {},
        _ref2$autoIncrementBa = _ref2.autoIncrementBase,
        autoIncrementBase = _ref2$autoIncrementBa === void 0 ? 0 : _ref2$autoIncrementBa,
        _ref2$unnamedRootBase = _ref2.unnamedRootBase,
        unnamedRootBase = _ref2$unnamedRootBase === void 0 ? ['root'] : _ref2$unnamedRootBase;

  let _rootNamer = rootNamer([...unnamedRootBase], autoIncrementBase),
      _rootNamer2 = _slicedToArray(_rootNamer, 3),
      nextRootName = _rootNamer2[0],
      incremented = _rootNamer2[1],
      namer = _rootNamer2[2];

  functionParameterNames.forEach((functionParameterName, functionParameterIdx) => {
    let inc;

    if (Array.isArray(functionParameterName)) {
      const matchedJsdoc = shallowJsdocParameterNames[functionParameterIdx] || jsdocParameterNames[functionParameterIdx];
      let rootName;

      if (functionParameterName[0]) {
        rootName = functionParameterName[0];
      } else if (matchedJsdoc && matchedJsdoc.name) {
        rootName = matchedJsdoc.name;

        if (matchedJsdoc.type && matchedJsdoc.type.search(checkTypesRegex) === -1) {
          return;
        }
      } else {
        rootName = nextRootName;
        inc = incremented;

        var _namer = namer();

        var _namer2 = _slicedToArray(_namer, 3);

        nextRootName = _namer2[0];
        incremented = _namer2[1];
        namer = _namer2[2];
      }

      const _functionParameterNam = functionParameterName[1],
            hasRestElement = _functionParameterNam.hasRestElement,
            hasPropertyRest = _functionParameterNam.hasPropertyRest,
            rests = _functionParameterNam.rests,
            names = _functionParameterNam.names;

      if (!enableRestElementFixer && hasRestElement) {
        return;
      }

      names.forEach((paramName, idx) => {
        if (jsdocParameterNames && !jsdocParameterNames.find(({
          name
        }) => {
          return name === rootName;
        })) {
          if (!missingTags.find(({
            functionParameterName: fpn
          }) => {
            return fpn === rootName;
          })) {
            const emptyParamIdx = jsdocParameterNames.findIndex(({
              name
            }) => {
              return !name;
            });

            if (emptyParamIdx > -1) {
              missingTags.push({
                functionParameterIdx: emptyParamIdx,
                functionParameterName: rootName,
                inc,
                remove: true
              });
            } else {
              missingTags.push({
                functionParameterIdx: paramIndex[rootName],
                functionParameterName: rootName,
                inc
              });
            }
          }
        }

        if (!checkRestProperty && rests[idx]) {
          return;
        }

        const fullParamName = `${rootName}.${paramName}`;

        if (jsdocParameterNames && !jsdocParameterNames.find(({
          name
        }) => {
          return name === fullParamName;
        })) {
          missingTags.push({
            functionParameterIdx: paramIndex[functionParameterName[0] ? fullParamName : paramName],
            functionParameterName: fullParamName,
            inc,
            type: hasRestElement && !hasPropertyRest ? '...any' : undefined
          });
        }
      });
      return;
    }

    let funcParamName;
    let type;

    if (typeof functionParameterName === 'object') {
      if (!enableRestElementFixer && functionParameterName.restElement) {
        return;
      }

      funcParamName = functionParameterName.name;
      type = '...any';
    } else {
      funcParamName = functionParameterName;
    }

    if (jsdocParameterNames && !jsdocParameterNames.find(({
      name
    }) => {
      return name === funcParamName;
    })) {
      missingTags.push({
        functionParameterIdx: paramIndex[funcParamName],
        functionParameterName: funcParamName,
        inc,
        type
      });
    }
  });

  const fix = ({
    functionParameterIdx,
    functionParameterName,
    remove,
    inc,
    type
  }, tags) => {
    if (inc && !enableRootFixer) {
      return;
    }

    if (remove) {
      tags.splice(functionParameterIdx, 1, {
        name: functionParameterName,
        newAdd: true,
        tag: preferredTagName,
        type
      });
    } else {
      const expectedIdx = findExpectedIndex(tags, functionParameterIdx);
      tags.splice(expectedIdx, 0, {
        name: functionParameterName,
        newAdd: true,
        tag: preferredTagName,
        type
      });
    }
  };

  const fixer = () => {
    if (!jsdoc.tags) {
      jsdoc.tags = [];
    }

    missingTags.forEach(missingTag => {
      fix(missingTag, jsdoc.tags);
    });
  };

  missingTags.forEach(({
    functionParameterName
  }) => {
    utils.reportJSDoc(`Missing JSDoc @${preferredTagName} "${functionParameterName}" declaration.`, null, enableFixer ? fixer : null, node);
  });
}, {
  contextDefaults: true,
  meta: {
    fixable: 'code',
    schema: [{
      additionalProperties: false,
      properties: {
        autoIncrementBase: {
          default: 0,
          type: 'integer'
        },
        checkConstructors: {
          default: true,
          type: 'boolean'
        },
        checkGetters: {
          default: false,
          type: 'boolean'
        },
        checkRestProperty: {
          default: false,
          type: 'boolean'
        },
        checkSetters: {
          default: false,
          type: 'boolean'
        },
        checkTypesPattern: {
          type: 'string'
        },
        contexts: {
          items: {
            type: 'string'
          },
          type: 'array'
        },
        enableFixer: {
          type: 'boolean'
        },
        enableRestElementFixer: {
          type: 'boolean'
        },
        enableRootFixer: {
          type: 'boolean'
        },
        exemptedBy: {
          items: {
            type: 'string'
          },
          type: 'array'
        },
        unnamedRootBase: {
          items: {
            type: 'string'
          },
          type: 'array'
        }
      },
      type: 'object'
    }],
    type: 'suggestion'
  }
});

exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=requireParam.js.map